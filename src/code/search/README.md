## Search (탐색)

- 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정.

- 그래프, 트리 등의 자료구조 안에서 탐색을 하는 문제를 자주 다룬다.

- 대표적인 탐색 알고리즘으로 DFS, BFS가 있는데, 원리를 제대로 이해해야 코딩 테스트의 탐색 문제 유형을 풀 수 있다.

- 그 전제로 스택과 큐에 대한 이해가 전제되어야 하므로 사전 학습으로 스택과 큐, 재귀 함수를 간단히 정리하고자 한다.

### Data Structure (자료 구조)

- 데이터를 표현하고 관리하고 처리하기 위한 구조

- 스택과 큐는 자료구조의 기초 개념으로 다음의 두 핵심적인 함수로 구성된다.

* 삽입(Push): 데이터를 삽입한다.
* 삭제(Pop): 데이터를 삭제한다.

물론 실제로 스택과 큐를 사용할 때는 삽입과 삭제 외에도 오버플로와 언더플로를 고민해야 한다.<br>
오버플로는 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입 연산을 수행할 때 발생한다.<br>
즉, 저장 공간을 벗어나 데이터가 넘쳐흐를 때 발생한다. 반면에 특정한 자료구조에 데이터가<br>
전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태이므로 언더플로가 발생한다.

### Stack (스택)

- 스택은 박스 쌓기에 비유할 수 있다. 흔히 박스는 아래에서부터 위로 차곡차곡 쌓고 꺼낼 때에는 위에서 부터 꺼낸다.

- 이러한 구조를 선입후출(First In Last Out) 또는 후입선출(Last In First Out) 이라고 한다.

### Queue (큐)

- 큐는 대기 줄에 비유할 수 있다. 먼저 대기한 사람이 먼저 들어간다. 물론 새치기는 없다고 가정한다.

- 이러한 구조를 선입선출(First In First Out) 이라고 한다.

- ***파이썬으로 큐를 구현할 때는 collections 모듈에서 제공하는 deque 자료구조를 활용하자. 데이터를 넣고 빼는 속도가 리스트에 비해 효율적이다.***

```python
from collections import deque
queue = deque()
# 혹은 리스트가 미리 만들어진게 있다면 ex) array = [1,2,3,4]
# queue = deque(array) 도 가능하다.
queue.append(5) # 삽입
queue.popleft() # First out
queue.reverse() # 역순으로 리스트 바꾸기
```

### Recursive Function (재귀 함수)

- 자기 자신을 다시 호출하는 함수

- 자기 자신을 다시 호출하기 때문에 호출의 횟수를 카운팅하거나, 변수 값이 어떤 조건을 만족하게 되었을때, 종료를 하도록 해야한다.

- 연속해서 호출되는 함수는 메인 메모리의 스택 공간에 적재되므로 재귀 함수는 스택 자료구조와 같다는 말은 틀린 말이 아니다.

재귀 함수를 이용하는 대표적 예제로는 팩토리얼 문제가 있다. 팩토리얼 기호는 느낌표(!)를 사용하며 n!는 1 x 2 x 3 x ... x (n-1) x n을 의미한다.<br>
수학적으로 0!과 1!의 값은 1로 같다는 성질을 이용하여 팩토리얼 함수는 n이 1이하가 되었을 때 함수를 종료하는 재귀 함수의 형태로 구현할 수 있다.<br><br>
반복문을 사용하는 방식과 재귀함수를 사용하는 방식 둘 다 구현하는데 같은 값을 가진다.<br>
그렇다면 반복문 대신에 재귀 함수를 사용했을 때 얻을 수 있는 장점은 무엇일까?<br>
바로 재귀 함수가 수학의 점화식을 그대로 소스코드로 옮겼기 때문이다.<br>
같은 행식이 반복되는, 하지만 변수는 달라지는 형태의 구조는 점화식으로 구성했을 때 효과적이다.<br>
이는 나중에 배울 다이나믹 프로그래밍(DP)로 이어지기 때문에 중요하다.<br>
  
***점화식***
* n이 0 혹은 1일때 : factorial(n) = 1 # 재귀함수의 종료 조건
* n이 1보다 클때   : factorial(n) = n * factorial(n - 1)

### DFS (Depth-First Search)

- 깊이 우선 탐색, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

- 깊이와 관련이 있기 때문에 스택 자료구조를 이용하여 동작한다.

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 1, 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

***방문 처리는 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다. 방문 처리를 함으로써 각 노드를 한 번씩만 처리할 수 있다.***

### 5-1 stackexample.py

- 스택 예제, 파이썬에서 스택을 이용할 때에는 별도의 라이브러리를 사용할 필요가 없다.
```bash
$ python stackexample.py

[5, 2, 3, 1]
[1, 3, 2, 5]
```

append()와 pop() 메서드를 이용하면 스택 자료구조와 동일하게 동작한다.<br>
append()는 리스트의 가장 뒤쪽에 데이터를 삽입하고,<br>
pop()은 리스트의 가장 뒤쪽의 데이터를 꺼낸다.<br>

### 5-2 queueexample.py

- 큐 예제, 파이썬에서 큐를 이용할 때에는 기본 라이브러리인 collections의 deque 객체를 생성하여 리스트처럼 활용한다.
```bash
$ python queueexample.py

[3, 7, 1, 4]
[4, 1, 7, 3]
```

append()는 기존의 list 자료형에서 사용하던 기능과 같지만, pop()  대신 popleft()를 사용한다.

### 5-4 recursivefunctionbreak.py

- 재귀 함수를 실행시키고, 시작 지점과 종료 지점에 대해 알 수 있어서 좋은 예시인 것 같다.

```bash
$ python recursivefunctionbreak.py

1 번째 재귀 함수에서 2 번째 재귀 함수를 호출합니다.
2 번째 재귀 함수에서 3 번째 재귀 함수를 호출합니다.
3 번째 재귀 함수에서 4 번째 재귀 함수를 호출합니다.

.
.
.

97 번째 재귀 함수에서 98 번째 재귀 함수를 호출합니다.
98 번째 재귀 함수에서 99 번째 재귀 함수를 호출합니다.
99 번째 재귀 함수에서 100 번째 재귀 함수를 호출합니다.

.
.
.

99 번째 재귀 함수를 종료합니다.
98 번째 재귀 함수를 종료합니다.
97 번째 재귀 함수를 종료합니다.

.
.
.

3 번째 재귀 함수를 종료합니다.
2 번째 재귀 함수를 종료합니다.
1 번째 재귀 함수를 종료합니다.
```

마지막 실행한 것부터 종료된다는 점으로 스택형 구조라는 것을 한번 더 알 수 있게 되었다.

### 5-5 factorial.py

- 팩토리얼을 구현하기 위해 반복문, 재귀함수 둘 다 사용해 볼 수 있어서 좋았다.

```bash
python factorial.py
input n!(factorial) : 5!

반복문을 사용해서 얻은 팩토리얼:  120
재귀함수를 사용해서 얻은 팩토리얼:  120
```

입력되는 순서는 5, 4, 3, 2, 1, 0 순서인데 1보다 작거나 같으면 1을 리턴한다.<br>
따라서 

f(0) = 1,   
f(1) = 1 \* f(0) = 1 \* 1 = 1,  
f(2) = 2 \* f(1) = 2 \* 1 = 2,  
f(3) = 3 \* f(2) = 3 \* 2 = 6,  
f(4) = 4 \* f(3) = 4 \* 6 = 24,  
f(5) = 5 \* f(4) = 5 \* 24 = 120

이렇게 계산 된다.
